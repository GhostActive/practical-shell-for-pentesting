#! /bin/bash
#
# template
#
# Copyright (C) 2021 GhostActive
#
# Author
#    GhostActive, https://github.com/ghostactive
#
# License
#    GNU General Public License v3.0
#
# Version
#    1.0
#

#
# Flag whether placeholder should be shown
#
BOOL_SHOW_MODE="False"

#
# Flag whether templates should be edit with editor
#
BOOL_EDIT_MODE="False"

#
# Position in args of template source (path or '-')
#
INT_SRC_POS=1


print_help(){

    echo ""
    echo "template - Replaces placeholders from given template."
    echo ""
    echo "Usage: template [-e|-s] (-|FILE) [KEY=VALUE...]"
    echo ""
    echo "Options:"
    echo "    -e      Enables post-editing mode and opens configured \$EDITOR while"
    echo "            processing"    
    echo "    -h      Print this help message"
    echo "    -s      Enables show mode listing all placeholders found in template"
    echo ""
    echo "Description:"
    echo "    The script replaces placeholder with format '{{ NAME }}' in a given"
    echo "    template."
    echo ""
    echo "    Input:  Two different input types are supported: Reading from stdin (-) and"
    echo "            from file (FILE). Depending on the input type, the script expects"
    echo "            '-' or an existing FILE."
    echo ""
    echo "    Mode:   By the flags -s (show mode) and -e (edit mode) the behaviour can be"
    echo "            controlled. In show mode the script only reads the template,"
    echo "            extracts the placeholders and prints them out. In editing mode,"
    echo "            after replacing the placeholders the configured text editor is"
    echo "            opened for further processing."
    echo ""
    echo "    Values: Any number of key-value pairs can be passed. The key name must"
    echo "            corresponds to the name of the placeholder (case sensitive). If not"
    echo "            all placeholders from the template are specified in argument list,"
    echo "            they will be skipped and printed to output without further"
    echo "            modification. Keys and values are separated by '=', for example"
    echo "            'name=Joe'."
    echo ""
    echo "    HINT: The used text editor is defined as global environment variable"
    echo "          \$EDITOR. It should be checked that the used editor does not write"
    echo "          (logging) messages to stdout or stderr during the process. Because the"
    echo "          output of this script is also written to stdout - in bad case mixing"
    echo "          with tool's output. Furthermore, the name of created temporary file,"
    echo "          loaded to text editor, should not be changed. Otherwise the changes"
    echo "          from text editor are not applied. After finishing editing, the file"
    echo "          must be saved and the text editor closed."
    echo ""
    echo "Examples:"
    echo "    # Read template from stdin"
    echo "    echo '{{ message }}' | template - message='Hello World'"
    echo ""
    echo "    # Read template from file and open with text editor"
    echo "    template -e input.txt message='Hello World' name=Joe age=42"
    echo ""
    echo "    # Read template and show placeholder"
    echo "    template -s input.txt"
    echo ""
}

while getopts ":hse" ARGUMENT
do
    case "$ARGUMENT" in
        e)
            BOOL_EDIT_MODE="True"
            ((INT_SRC_POS++))
            ;;
        s)
            BOOL_SHOW_MODE="True"
            ((INT_SRC_POS++))
            ;;
        h)
            print_help
            exit 0
            ;;
   esac
done

STR_SRC="${!INT_SRC_POS}"

#
# Check input mode
#
if [ ! "$STR_SRC" = "-" ]
then
    if [[ -z $STR_SRC ]];then
        echo "Error: No source for a template has been defined."
        print_help
        exit 1
    fi
    
    if [[ ! -f $STR_SRC ]];then
        echo "Error: The specified path could not be found '$STR_SRC'."
        exit 2
    fi
fi

#
# Write template to internal buffer
#
if [[ "$STR_SRC" != "-" || ! -t 0 ]]
then
    CONTENT="$(cat $STR_SRC)"
fi

#
# Extract placeholders from template and exit - if SHOW_MODE is enabled
#
if [ "$BOOL_SHOW_MODE" = "True" ]
then
    echo "$CONTENT" | grep -onE "\{\{ [a-zA-Z0-9\.]+ \}\}" | sort -u
    exit 0
fi

#
# Replace key-value pairs in temp file 
#
for PAIR in "${@:$INT_SRC_POS+1}"
do
    # escape slahes and backslashes
    PAIR="$(echo $PAIR | sed 's/\\/\\\\/g' | sed 's/\//\\\//g' )"
    KEY="{{ $(echo $PAIR | cut -f 1 -d '=') }}"
    VALUE="$(echo $PAIR | cut -f 2- -d '=')"
    CONTENT=$(echo "$CONTENT" | sed "s/$KEY/$VALUE/g")
done

#
# Opens text editor for post-editing the template - if EDIT_MODE is enabled
#
if [ "$BOOL_EDIT_MODE" = "True" ]
then
    if [ -z ${EDITOR+x} ]
    then
        echo "The environment variable $EDITOR is not set."
        exit 1
    fi

    TMP_FILE=$(mktemp)
    echo "$CONTENT" > $TMP_FILE
    $EDITOR $TMP_FILE < /dev/tty > /dev/tty
    CONTENT="$(cat $TMP_FILE)"
    rm $TMP_FILE
fi

#
# Write template to stdout
#
echo "$CONTENT"
